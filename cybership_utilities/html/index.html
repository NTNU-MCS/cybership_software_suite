<!doctype html>
<meta charset="utf-8" />
<title>ROS 2 Web Interface</title>
<style>
    body {
        font-family: system-ui, sans-serif;
        max-width: 920px;
        margin: 2rem auto;
    }

    fieldset {
        margin: 1rem 0;
        padding: 1rem;
        border-radius: 10px;
        border: 1px solid #ddd;
    }

    legend {
        font-weight: 600;
    }

    .row {
        margin: .5rem 0;
        display: flex;
        gap: .5rem;
        align-items: center;
    }

    label {
        min-width: 9rem;
    }

    select {
        min-width: 28rem;
    }

    #log {
        background: #f7f7f7;
        padding: .75rem;
        border-radius: 8px;
        max-height: 260px;
        overflow: auto;
    }

    .muted {
        color: #555;
    }
</style>

<h1>ROS 2 Mux (Web UI)</h1>
<div class="muted">Web UI for switching mux inputs and toggling thrusters / thrust allocation via ROS 2 services.</div>
<div class="row">
    <label>WebSocket URL</label>
    <input id="url" size="36" />
    <button id="connect">Connect</button>
    <span id="status" class="muted">disconnected</span>
</div>
<div class="muted">Connects to <code>web_interface_server.py</code> to call ROS 2 services from your browser.</div>

<fieldset>
    <legend>Namespace</legend>
    <div class="muted">All service calls are made under this namespace (e.g. <code>/voyager</code>, <code>/enterprise</code>, <code>/drillship</code>).</div>
    <input id="ns" placeholder="/voyager" style="width: 24rem" />
    <div id="nsButtons" style="margin-top: 1rem; display: flex; gap: 0.5rem; flex-wrap: wrap;"></div>
</fieldset>

<fieldset>
    <legend>Thrusters</legend>
    <div class="muted">Enables/disables the thruster system on the physical platform (if your setup exposes these Empty services). In simulation this is usually unavailable or has no effect.</div>
    <div class="row">
        <button id="thrActivate">Activate</button>
        <button id="thrDeactivate">Deactivate</button>
        <span id="thrResult" class="muted"></span>
    </div>
    <div class="muted">Calls <code>&lt;ns&gt;/thrusters/activate</code> and <code>&lt;ns&gt;/thrusters/deactivate</code> (std_srvs/Empty)</div>

</fieldset>

<fieldset>
    <legend>Thrust Allocation (Lifecycle)</legend>
    <div class="muted">Starts/stops the thrust allocation node using ROS 2 lifecycle transitions (configure/activate/deactivate).</div>
    <div class="row">
        <label>Node</label>
        <input id="allocNode" placeholder="(auto) e.g. voyager_thrust_allocator" style="width: 24rem" />
        <button id="allocState">Get state</button>
        <span id="allocStateText" class="muted"></span>
    </div>
    <div class="row">
        <button id="allocActivate">Activate</button>
        <button id="allocDeactivate">Deactivate</button>
        <span id="allocResult" class="muted"></span>
    </div>
    <div class="muted">Calls <code>&lt;ns&gt;/&lt;node&gt;/get_state</code> and <code>&lt;ns&gt;/&lt;node&gt;/change_state</code> (lifecycle_msgs)</div>
</fieldset>

<fieldset>
    <legend>Force Mux</legend>
    <div class="muted">Selects which force command source drives <code>control/force/command</code> via <code>topic_tools/mux</code>.</div>
    <div class="row">
        <button id="forceList">List topics</button>
        <span id="forceCount" class="muted"></span>
    </div>
    <div class="row">
        <label>Topic</label>
        <select id="forceSelect"></select>
        <button id="forceChoose">Select</button>
        <span id="forceResult" class="muted"></span>
    </div>
</fieldset>

<fieldset>
    <legend>Velocity Mux</legend>
    <div class="muted">Selects which velocity command source drives the velocity controller (when a velocity mux is present).</div>
    <div class="row">
        <button id="velList">List topics</button>
        <span id="velCount" class="muted"></span>
    </div>
    <div class="row">
        <label>Topic</label>
        <select id="velSelect"></select>
        <button id="velChoose">Select</button>
        <span id="velResult" class="muted"></span>
    </div>
</fieldset>

<pre id="log"></pre>
<div class="muted">Log shows responses/errors from the WebSocket bridge.</div>

<script type="module">
    // ---------------- Simple JSON WebSocket Protocol ----------------
    let ws;
    let services = [];
    const el = (id) => document.getElementById(id);
    const logEl = el("log");
    const log = (...a) => {
        logEl.textContent += a.map(x => typeof x === 'string' ? x : JSON.stringify(x)).join(' ') + "\n";
        logEl.scrollTop = logEl.scrollHeight;
    };
    const setStatus = (s) => el("status").textContent = s;
    const getNamespace = () => (el("ns").value || "").trim().replace(/\/+$/, "");
    const getAllocatorNode = () => (el("allocNode").value || "").trim();

    // Default WebSocket URL from the current address bar.
    // Examples:
    // - http://192.168.1.20/...  -> ws://192.168.1.20:8765
    // - https://robot.local/...  -> wss://robot.local:8765
    // - file:///...              -> ws://localhost:8765
    (() => {
        const urlInput = el("url");
        const host = window.location.hostname || "localhost";
        const wsProto = window.location.protocol === "https:" ? "wss" : "ws";
        urlInput.value = `${wsProto}://${host}:8765`;
    })();

    // Send a message and wait for response
    async function sendMessage(message, timeoutMs = 5000) {
        return new Promise((resolve, reject) => {
            const handler = (event) => {
                try {
                    const response = JSON.parse(event.data);
                    if (response.type === "error") {
                        reject(new Error(response.message));
                    } else {
                        resolve(response);
                    }
                    ws.removeEventListener("message", handler);
                } catch (e) {
                    reject(e);
                }
            };

            const timeout = setTimeout(() => {
                ws.removeEventListener("message", handler);
                reject(new Error("Request timeout"));
            }, timeoutMs);

            ws.addEventListener("message", handler);
            ws.send(JSON.stringify(message));

            // Clear timeout when done
            ws.addEventListener("message", () => clearTimeout(timeout), { once: true });
        });
    }

    el("connect").onclick = () => {
        const url = el("url").value.trim();
        ws = new WebSocket(url);
        ws.onopen = () => {
            setStatus("connected to " + url);
            log("Connected to server");
        };
        ws.onclose = () => {
            setStatus("closed");
            log("Connection closed");
        };
        ws.onerror = (e) => {
            setStatus("error");
            log("WebSocket error:", e?.message ?? "");
        };

        ws.onmessage = (ev) => {
            try {
                const msg = JSON.parse(ev.data);
                if (msg.type === "serverInfo") {
                    log("Server:", msg.name, msg.version);
                } else if (msg.type === "services") {
                    services = msg.services || [];
                    log(`Found ${services.length} services`);

                    // Extract and populate namespace buttons
                    populateNamespaceButtons(services);
                }
            } catch (e) {
                log("Error parsing message:", e.message);
            }
        };
    };


    // ---------------- UI Helpers ----------------
    function fillSelect(selectEl, topics, countEl) {
        selectEl.innerHTML = "";
        topics.forEach(t => {
            const opt = document.createElement("option");
            opt.value = t;
            opt.textContent = t;
            selectEl.appendChild(opt);
        });
        countEl.textContent = `${topics.length} topic(s)`;
    }

    function extractNamespaces(services) {
        const namespaces = new Set();
        services.forEach(svc => {
            // Extract the first component after the root /
            // e.g., /voyager/control/force/command/mux -> voyager
            const parts = svc.name.split('/').filter(p => p.length > 0);
            if (parts.length > 0) {
                namespaces.add(parts[0]);
            }
        });
        return Array.from(namespaces).sort();
    }

    function populateNamespaceButtons(services) {
        const container = el('nsButtons');
        container.innerHTML = '';
        const namespaces = extractNamespaces(services);

        namespaces.forEach(ns => {
            const btn = document.createElement('button');
            btn.textContent = ns;
            btn.style.padding = '0.4rem 0.8rem';
            btn.style.fontSize = '0.9rem';
            btn.onclick = () => {
                el('ns').value = ns;
            };
            container.appendChild(btn);
        });
    }

    // ---------------- UI Actions ----------------
    el("forceList").onclick = async () => {
        try {
            const namespace = getNamespace();
            const response = await sendMessage({
                type: "mux_list",
                namespace: namespace,
                mux_name: "force_mux"
            });

            if (response.type === "mux_list_response") {
                fillSelect(el('forceSelect'), response.topics, el('forceCount'));
                log(`Force mux: ${response.topics.length} topics`);
            }
        } catch (e) {
            el('forceCount').textContent = `Error: ${e.message}`;
            log("Error listing force topics:", e.message);
        }
    };

    el("velList").onclick = async () => {
        try {
            const namespace = getNamespace();
            const response = await sendMessage({
                type: "mux_list",
                namespace: namespace,
                mux_name: "velocity_mux"
            });

            if (response.type === "mux_list_response") {
                fillSelect(el('velSelect'), response.topics, el('velCount'));
                log(`Velocity mux: ${response.topics.length} topics`);
            }
        } catch (e) {
            el('velCount').textContent = `Error: ${e.message}`;
            log("Error listing velocity topics:", e.message);
        }
    };

    el("forceChoose").onclick = async () => {
        try {
            const namespace = getNamespace();
            const topic = el('forceSelect').value.trim();
            if (!topic) {
                el('forceResult').textContent = 'Pick a topic';
                return;
            }

            const response = await sendMessage({
                type: "mux_select",
                namespace: namespace,
                mux_name: "force_mux",
                topic: topic
            });

            if (response.type === "mux_select_response") {
                el('forceResult').textContent = response.success
                    ? `Selected (prev: ${response.prev_topic || '-'})`
                    : 'Select rejected';
                log(`Force mux selected: ${topic}`);
            }
        } catch (e) {
            el('forceResult').textContent = `Error: ${e.message}`;
            log("Error selecting force topic:", e.message);
        }
    };

    el("velChoose").onclick = async () => {
        try {
            const namespace = getNamespace();
            const topic = el('velSelect').value.trim();
            if (!topic) {
                el('velResult').textContent = 'Pick a topic';
                return;
            }

            const response = await sendMessage({
                type: "mux_select",
                namespace: namespace,
                mux_name: "velocity_mux",
                topic: topic
            });

            if (response.type === "mux_select_response") {
                el('velResult').textContent = response.success
                    ? `Selected (prev: ${response.prev_topic || '-'})`
                    : 'Select rejected';
                log(`Velocity mux selected: ${topic}`);
            }
        } catch (e) {
            el('velResult').textContent = `Error: ${e.message}`;
            log("Error selecting velocity topic:", e.message);
        }
    };

    // -------------- Thrusters (Empty) --------------
    el("thrActivate").onclick = async () => {
        try {
            el('thrResult').textContent = 'Activating…';
            const namespace = getNamespace();

            const response = await sendMessage({
                type: "thruster_activate",
                namespace: namespace,
                candidates: ["/thrusters/activate", "/thruster/activate", "/thruster/enable"]
            });

            if (response.type === "thruster_response" && response.success) {
                el('thrResult').textContent = `Activated via ${response.service}`;
                log(`Thrusters activated: ${response.service}`);
            }
        } catch (e) {
            el('thrResult').textContent = `Error: ${e.message}`;
            log("Error activating thrusters:", e.message);
        }
    };

    el("thrDeactivate").onclick = async () => {
        try {
            el('thrResult').textContent = 'Deactivating…';
            const namespace = getNamespace();

            const response = await sendMessage({
                type: "thruster_deactivate",
                namespace: namespace,
                candidates: ["/thrusters/deactivate", "/thruster/disable"]
            });

            if (response.type === "thruster_response" && response.success) {
                el('thrResult').textContent = `Deactivated via ${response.service}`;
                log(`Thrusters deactivated: ${response.service}`);
            }
        } catch (e) {
            el('thrResult').textContent = `Error: ${e.message}`;
            log("Error deactivating thrusters:", e.message);
        }
    };

    // -------------- Thrust Allocation (Lifecycle) --------------
    function formatLifecycleState(state) {
        if (!state) return "";
        const label = state.label || "";
        const id = (state.id ?? "");
        return label ? `${label} (${id})` : String(id);
    }

    el("allocState").onclick = async () => {
        try {
            el('allocResult').textContent = '';
            el('allocStateText').textContent = 'Loading…';
            const namespace = getNamespace();
            const nodeName = getAllocatorNode();

            const response = await sendMessage({
                type: "allocator_state",
                namespace: namespace,
                node_name: nodeName || undefined,
            });

            if (response.type === "allocator_state_response") {
                el('allocStateText').textContent = `${response.node_name}: ${formatLifecycleState(response.state)}`;
                log(`Allocator state: ${response.node_name} -> ${formatLifecycleState(response.state)}`);
            }
        } catch (e) {
            el('allocStateText').textContent = `Error: ${e.message}`;
            log("Error getting allocator state:", e.message);
        }
    };

    el("allocActivate").onclick = async () => {
        try {
            el('allocResult').textContent = 'Activating…';
            const namespace = getNamespace();
            const nodeName = getAllocatorNode();

            const response = await sendMessage({
                type: "allocator_activate",
                namespace: namespace,
                node_name: nodeName || undefined,
            });

            if (response.type === "allocator_response" && response.success) {
                el('allocResult').textContent = `Activated (${formatLifecycleState(response.state)})`;
                el('allocStateText').textContent = `${response.node_name}: ${formatLifecycleState(response.state)}`;
                log(`Allocator activated: ${response.node_name}`);
            }
        } catch (e) {
            el('allocResult').textContent = `Error: ${e.message}`;
            log("Error activating allocator:", e.message);
        }
    };

    el("allocDeactivate").onclick = async () => {
        try {
            el('allocResult').textContent = 'Deactivating…';
            const namespace = getNamespace();
            const nodeName = getAllocatorNode();

            const response = await sendMessage({
                type: "allocator_deactivate",
                namespace: namespace,
                node_name: nodeName || undefined,
            });

            if (response.type === "allocator_response" && response.success) {
                el('allocResult').textContent = `Deactivated (${formatLifecycleState(response.state)})`;
                el('allocStateText').textContent = `${response.node_name}: ${formatLifecycleState(response.state)}`;
                log(`Allocator deactivated: ${response.node_name}`);
            }
        } catch (e) {
            el('allocResult').textContent = `Error: ${e.message}`;
            log("Error deactivating allocator:", e.message);
        }
    };


</script>